Sure, here is a refactored version of your VertCoin contract. This version clarifies the code structure and adds comments to enhance readability:

```sol
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.0;

import "@openzeppelin/contracts/token/ERC20/ERC20.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "./MultiSigWallet.sol";

// VertCoin contract that extends the functionality of an ERC-20 token.
contract VertCoin is ERC20, Ownable {
    // Stores the amount of tokens staked by each staker.
    mapping(address => uint256) private stakes;
    // Stores the address of the multi-sig wallet associated with each staker.
    mapping(address => address) public stakerToMultiSig;

    // Event emitted when a stake is placed.
    event StakePlaced(address indexed staker, uint256 amount, address indexed multiSigWallet);
    // Event emitted when a stake is released.
    event StakeReleased(address indexed staker, uint256 amount);
    // Event emitted when a stake is forfeited.
    event StakeForfeited(address indexed staker, uint256 amount);

    // Constructor that defines the name and symbol of the token.
    constructor() ERC20("VertCoin", "VTC") {}
    
    // Allows users to stake a specified amount of tokens.
    function stake(uint256 amount, address multiSigWallet) public {
        // Ensures the staker has enough tokens to stake.
        require(balanceOf(msg.sender) >= amount, "Insufficient balance to stake.");
       
        // Updates the stake amount and multi-sig wallet address.
        stakes[msg.sender] += amount;
        stakerToMultiSig[msg.sender] = multiSigWallet;

        emit StakePlaced(msg.sender, amount, multiSigWallet);
    }
    
    // Allows the contract owner to release a user's stake.
    function releaseStake(address staker) external onlyOwner {
        uint256 stakeAmount = stakes[staker];

        // Ensures the user has a stake to release.
        require(stakeAmount > 0, "No stake to release.");
        
        // Transfers the staked tokens from the multi-sig wallet to the staker.
        _transfer(stakerToMultiSig[staker], staker, stakeAmount);

        // Resets the staker's stake amount and multi-sig wallet address.
        stakes[staker] = 0;
        delete stakerToMultiSig[staker];

        emit StakeReleased(staker, stakeAmount);
    }
    
    // Allows the contract owner to forfeit a user's stake.
    function forfeitStake(address staker) external onlyOwner {
        uint256 stakeAmount = stakes[staker];

        // Ensures the user has a stake to forfeit.
        require(stakeAmount > 0, "No stake to forfeit.");
        
        // Resets the staker's stake amount and multi-sig wallet address.
        stakes[staker] = 0;
        delete stakerToMultiSig[staker];

        emit StakeForfeited(staker, stakeAmount);
    }
    
    // Returns the stake amount of a specified staker.
    function getStake(address staker) external view returns (uint256) {
        return stakes[staker];
    }
}
```